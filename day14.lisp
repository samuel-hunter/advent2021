(defpackage #:advent2021.day14
  (:use #:cl #:alexandria #:cl-ppcre #:advent2021.util)
  (:export #:solve-part-1 #:solve-part-2))

(in-package #:advent2021.day14)



(with-puzzle-file (stream)
  (defparameter +template+
    (read-line stream))
  (read-line stream)
  (defparameter +rules+
    (loop :with table := (make-hash-table :test 'equal)
          :for line := (read-line stream nil)
          :while line
          :for (pair result) := (split " -> " line)
          :do (setf (gethash (cons (char pair 0) (char pair 1))
                             table)
                    (char result 0))
          :finally (return table))))

(defun initial-polymer ()
  "Encode the template as a table of the count of element pairs."
  (loop :with pair-table := (make-hash-table :test 'equal)
        ;; Iterate across each pair of characters in the template, e.g. for the
        ;; template "NNCB", (a b) is bound to (#\N #\N), (#\N #\C), then (#\C
        ;; #\B).

        ;; By encoding the table as a count of all pairs, subsequent
        ;; generations only need to apply a rule twice for each unique pair,
        ;; instead of applying them once for each pair that exists.
        :for (a b) :on (coerce +template+ 'list)
        :while b

        :do (incf (gethash (cons a b) pair-table 0))
        :finally (return pair-table)))

(defun polymerize (polymer)
  "Return a fresh pair table generated by applying the problem-set rules on
   each pair."
  (loop :with next-polymer := (make-hash-table :test 'equal)
        :for (a . b) :being :the :hash-keys :of polymer
        :using (hash-value count)
        :for c := (gethash (cons a b) +rules+)

        :do (incf (gethash (cons a c) next-polymer 0) count)
            (incf (gethash (cons c b) next-polymer 0) count)
        :finally (return next-polymer)))

(defun count-elements (polymer)
  "Return a table of the count of all elements."
  (loop :with freq-table := (make-hash-table)
        :with first-elm := (char +template+ 0)
        :with last-elm := (char +template+ (1- (length +template+)))

        :for (a . b) :being :the :hash-keys :of polymer
        :using (hash-value count)
        ;; "Count" each element in each pair only half as often, as they appear
        ;; encoded as pairs twice as much than encoded as a string.
        :do (incf (gethash a freq-table 0) (/ count 2))
            (incf (gethash b freq-table 0) (/ count 2))

        ;; Bump up the first and last elements, as they're only
        ;; counted once.
        :finally (incf (gethash first-elm freq-table) 1/2)
                 (incf (gethash last-elm freq-table) 1/2)
                 (return freq-table)))

(defun element-range (freq-table)
  "Return the difference of the frequencies of the most common and least common
   elements."
  (loop :for count :being :the :hash-values :of freq-table
        :maximize count :into highest
        :minimize count :into lowest
        :finally (return (- highest lowest))))

(defun solve (n-generations)
  (loop :with polymer := (initial-polymer)
        :repeat n-generations
        :do (setf polymer (polymerize polymer))
        :finally (return (element-range (count-elements polymer)))))

(defun solve-part-1 ()
  (solve 10))

(defun solve-part-2 ()
  (solve 40))
